<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Triangulos Interativos - PyScript</title>

    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.3.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.3.1/core.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #fafafa;
        }

        .container {
            display: flex;
            gap: 20px;
        }

        #controls {
            width: 260px;
        }

        #canvas-container {
            border: 1px solid #000;
            background: white;
            position: relative;
        }

        canvas {
            border: 1px solid #aaa;
            display: block;
        }

        .input-row {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

<h2>Triangulos Interativos (PyScript)</h2>

<div class="container">

    <div id="controls">
        <div class="input-row">
            Lado A: <input type="text" id="ladoA" value="3">
        </div>

        <div class="input-row">
            Lado B: <input type="text" id="ladoB" value="4">
        </div>

        <div class="input-row">
            Lado C: <input type="text" id="ladoC" value="5">
        </div>

        <button id="gerar">Gerar Segmentos</button>
        <button id="excluir">Excluir Triangulo Selecionado</button>

        <h4>Status:</h4>
        <div id="status">Aguardando dados.</div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="700" height="500"></canvas>
    </div>

</div>

<!-- ================== PYTHON (PyScript) ====================== -->
<script type="py">
from js import document
from pyodide.ffi import create_proxy
import math

canvas = document.getElementById("canvas")
ctx = canvas.getContext("2d")

# grupo: {
#   "segments":[...],
#   "locked":bool,
#   "polygon":[(x,y),...],
#   "can_triangle":bool,
#   "fillColor":str|None,
#   "right_angle": {"R":(x,y), "A":(x,y), "B":(x,y)} | None,
#   "sides":[a,b,c] (ordenados)
# }
groups = []
active_group = None
selected_group = None

dragging_segment = None      # (group, seg)
dragging_point = None        # (group, seg, "p1"/"p2")
dragging_triangle_group = None
last_mouse = None

zoom = 1.0
SNAP_DIST = 12

# ----------------- FUNCOES AUXILIARES --------------------
def set_inputs_enabled(enabled: bool):
    for _id in ("ladoA", "ladoB", "ladoC", "gerar"):
        document.getElementById(_id).disabled = not enabled

def distance(p1, p2):
    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5

def draw_point(x, y, color):
    ctx.beginPath()
    ctx.fillStyle = color
    ctx.arc(x, y, 7, 0, 6.28)
    ctx.fill()

def classify_by_angles(a, b, c):
    """
    Classifica pelos angulos usando apenas os lados digitados.
    Devolve "acute", "right" ou "obtuse".
    a <= b <= c (ordenados).
    """
    a, b, c = sorted([a, b, c])
    if c == 0:
        return "acute"
    lhs = a*a + b*b
    rhs = c*c
    rel = abs(lhs - rhs) / max(rhs, 1.0)
    # Tolerância bem pequena porque vem dos dados numéricos do aluno
    if rel < 1e-6:
        return "right"
    elif lhs > rhs:
        return "acute"
    else:
        return "obtuse"

def draw_right_angle_mark(group):
    """Desenha o quadradinho no vertice reto, se houver."""
    ra = group.get("right_angle")
    if not ra:
        return
    (Rx, Ry) = ra["R"]
    (Ax, Ay) = ra["A"]
    (Bx, By) = ra["B"]

    v1x, v1y = Ax - Rx, Ay - Ry
    v2x, v2y = Bx - Rx, By - Ry
    d1 = math.hypot(v1x, v1y)
    d2 = math.hypot(v2x, v2y)
    if d1 == 0 or d2 == 0:
        return
    v1x /= d1; v1y /= d1
    v2x /= d2; v2y /= d2

    size = 18.0
    p1x = Rx + v1x * size
    p1y = Ry + v1y * size
    p3x = Rx + v2x * size
    p3y = Ry + v2y * size
    p2x = p1x + v2x * size
    p2y = p1y + v2y * size

    ctx.beginPath()
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.moveTo(Rx, Ry)
    ctx.lineTo(p1x, p1y)
    ctx.lineTo(p2x, p2y)
    ctx.lineTo(p3x, p3y)
    ctx.stroke()

def draw_side_marks(group):
    """Risquinhos em lados iguais (apos formar o triangulo)."""
    lens = [seg["len"] for seg in group["segments"]]
    eps = 1e-2
    e01 = abs(lens[0] - lens[1]) <= eps
    e02 = abs(lens[0] - lens[2]) <= eps
    e12 = abs(lens[1] - lens[2]) <= eps

    ticks = [0, 0, 0]
    if e01 and e02:
        ticks = [1, 1, 1]   # equilatero
    elif e01 and not e02 and not e12:
        ticks = [1, 1, 0]
    elif e02 and not e01 and not e12:
        ticks = [1, 0, 1]
    elif e12 and not e01 and not e02:
        ticks = [0, 1, 1]

    for i, seg in enumerate(group["segments"]):
        if ticks[i] <= 0:
            continue
        (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
        dx = x2 - x1
        dy = y2 - y1
        d = math.hypot(dx, dy)
        if d == 0:
            continue
        mx = (x1 + x2) / 2.0
        my = (y1 + y2) / 2.0
        nx = -dy / d
        ny = dx / d
        size = 10.0
        ex = nx * size / 2.0
        ey = ny * size / 2.0

        ctx.beginPath()
        ctx.strokeStyle = "black"
        ctx.lineWidth = 2
        ctx.moveTo(mx - ex, my - ey)
        ctx.lineTo(mx + ex, my + ey)
        ctx.stroke()

def draw_segment_label(seg):
    """
    Desenha o valor do lado (medida digitada) próximo ao segmento.
    O texto acompanha o segmento ao mover/rotacionar.
    """
    (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
    dx = x2 - x1
    dy = y2 - y1
    d = math.hypot(dx, dy)
    if d == 0:
        return

    # ponto medio
    mx = (x1 + x2) / 2.0
    my = (y1 + y2) / 2.0

    # vetor perpendicular normalizado
    nx = -dy / d
    ny = dx / d

    # deslocamento para fora do segmento
    offset = 16.0
    tx = mx + nx * offset
    ty = my + ny * offset

    # texto: medida original do lado (na unidade digitada)
    val = seg.get("value", None)
    if val is None:
        return
    # mostrar sem casas decimais se for inteiro, senão 2 casas
    if abs(val - round(val)) < 1e-9:
        text = str(int(round(val)))
    else:
        text = f"{val:.2f}"

    ctx.save()
    ctx.font = "14px Arial"
    ctx.fillStyle = "black"
    ctx.fillText(text, tx, ty)
    ctx.restore()

def draw():
    ctx.setTransform(1, 0, 0, 1, 0, 0)
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.setTransform(zoom, 0, 0, zoom, 0, 0)

    for group in groups:
        # poligono (triangulo valido) se existir
        if group["polygon"] is not None:
            ctx.beginPath()
            if group.get("fillColor"):
                ctx.fillStyle = group["fillColor"]
            else:
                ctx.fillStyle = "rgba(0, 150, 255, 0.25)"
            v0, v1, v2 = group["polygon"]
            ctx.moveTo(*v0)
            ctx.lineTo(*v1)
            ctx.lineTo(*v2)
            ctx.closePath()
            ctx.fill()

            # marcações extras
            draw_side_marks(group)
            draw_right_angle_mark(group)

        # segmentos
        for seg in group["segments"]:
            (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
            ctx.beginPath()
            ctx.lineWidth = 4
            ctx.strokeStyle = seg["color"]
            ctx.moveTo(x1, y1)
            ctx.lineTo(x2, y2)
            ctx.stroke()
            draw_point(x1, y1, seg["color"])
            draw_point(x2, y2, seg["color"])

            # NOVO: desenhar a medida do lado
            draw_segment_label(seg)

def snap_endpoints(group):
    """Cola pontas proximas dentro de um mesmo grupo."""
    pts = []
    for seg in group["segments"]:
        pts.append(seg["p1"])
        pts.append(seg["p2"])

    n = len(pts)
    for i in range(n):
        for j in range(i + 1, n):
            p1 = pts[i]
            p2 = pts[j]
            if distance(p1, p2) <= SNAP_DIST:
                mx = (p1[0] + p2[0]) / 2
                my = (p1[1] + p2[1]) / 2
                p1[0], p1[1] = mx, my
                p2[0], p2[1] = mx, my

def check_triangle_formed(group):
    """Detecta conexao dos 3 segmentos."""
    global active_group, selected_group

    group["right_angle"] = None
    group["fillColor"] = None

    verts = {}
    for seg in group["segments"]:
        for key in ("p1", "p2"):
            p = seg[key]
            v = (round(p[0], 3), round(p[1], 3))
            verts[v] = verts.get(v, 0) + 1

    num_verts = len(verts)
    degrees = list(verts.values())

    # ----------- CASO 1: TRIANGULO FECHADO ----------
    if num_verts == 3 and all(d == 2 for d in degrees):
        group["locked"] = True
        active_group = None
        selected_group = group
        set_inputs_enabled(True)

        xs = [v[0] for v in verts.keys()]
        ys = [v[1] for v in verts.keys()]
        cx = sum(xs) / 3
        cy = sum(ys) / 3
        verts_sorted = sorted(verts.keys(), key=lambda v: math.atan2(v[1]-cy, v[0]-cx))
        v0, v1, v2 = verts_sorted

        # comprimentos geometricos (so para achar o vertice oposto ao maior lado)
        L01 = distance(v0, v1)
        L12 = distance(v1, v2)
        L20 = distance(v2, v0)

        if (L01 + L12 > L20) and (L01 + L20 > L12) and (L12 + L20 > L01):
            # classificação pelos lados digitados
            a, b, c = group["sides"]
            tipo = classify_by_angles(a, b, c)

            if tipo == "acute":
                group["fillColor"] = "rgba(255, 0, 0, 0.5)"   # vermelho
            elif tipo == "right":
                group["fillColor"] = "rgba(0, 200, 0, 0.5)"   # verde
            else:
                group["fillColor"] = "rgba(0, 0, 255, 0.5)"   # azul

            group["polygon"] = [v0, v1, v2]

            # segmentos pretos depois de formar
            for seg in group["segments"]:
                seg["color"] = "black"

            # angulo reto -> vertice oposto ao maior lado geometrico
            if tipo == "right":
                lens = [L01, L12, L20]
                max_idx = max(range(3), key=lambda i: lens[i])
                if max_idx == 0:
                    R = v2; A = v0; B = v1
                elif max_idx == 1:
                    R = v0; A = v1; B = v2
                else:
                    R = v1; A = v2; B = v0
                group["right_angle"] = {"R": R, "A": A, "B": B}

            nome = "acutangulo" if tipo=="acute" else "retangulo" if tipo=="right" else "obtusangulo"
            document.getElementById("status").innerText = (
                f"Triangulo valido formado! ({nome}) Voce pode inserir novos lados."
            )
        else:
            group["polygon"] = None
            document.getElementById("status").innerText = (
                "Segmentos conectados em loop, mas nao formam triangulo valido. Voce pode inserir novos lados."
            )
        return

    # ----------- CASO 2: CADEIA ABERTA CONECTADA (1-1-2-2) -----------  
    if not group["can_triangle"]:
        if num_verts == 4 and sorted(degrees) == [1, 1, 2, 2]:
            group["locked"] = True
            active_group = None
            selected_group = group
            set_inputs_enabled(True)
            group["polygon"] = None
            document.getElementById("status").innerText = (
                "Segmentos conectados em cadeia, mas esses lados nao formam triangulo. "
                "Voce pode inserir novos lados; este conjunto se move como bloco e "
                "as pontas ainda podem girar."
            )
            return

def gerar_segmentos(event=None):
    global groups, active_group, selected_group

    if active_group is not None:
        document.getElementById("status").innerText = (
            "Conecte primeiro o conjunto atual antes de gerar outro."
        )
        return

    try:
        a = float(document.getElementById("ladoA").value)
        b = float(document.getElementById("ladoB").value)
        c = float(document.getElementById("ladoC").value)
    except Exception:
        document.getElementById("status").innerText = "Valores invalidos."
        return

    esc = 40

    segs = [
        {"p1": [100, 100], "p2": [100 + a*esc, 100], "len": a*esc, "color": "red",  "value": a},
        {"p1": [100, 200], "p2": [100 + b*esc, 200], "len": b*esc, "color": "green","value": b},
        {"p1": [100, 300], "p2": [100 + c*esc, 300], "len": c*esc, "color": "blue", "value": c},
    ]

    can_triangle = (a + b > c) and (a + c > b) and (b + c > a)

    group = {
        "segments": segs,
        "locked": False,
        "polygon": None,
        "can_triangle": can_triangle,
        "fillColor": None,
        "right_angle": None,
        "sides": sorted([a, b, c]),
    }

    groups.append(group)
    active_group = group
    selected_group = group

    set_inputs_enabled(False)
    if can_triangle:
        document.getElementById("status").innerText = (
            "Arraste os segmentos para tentar formar o triangulo."
        )
    else:
        document.getElementById("status").innerText = (
            "Esses lados nao formam triangulo. Conecte os segmentos em cadeia; "
            "apos conectar, novos lados serao liberados e o conjunto ficara travado, "
            "com as pontas ainda girando."
        )
    draw()

document.getElementById("gerar").onclick = create_proxy(gerar_segmentos)

def excluir_triangulo(event=None):
    global groups, active_group, selected_group

    if selected_group is None:
        document.getElementById("status").innerText = "Nenhum triangulo selecionado."
        return

    if selected_group is active_group:
        active_group = None
        set_inputs_enabled(True)

    groups = [g for g in groups if g is not selected_group]
    selected_group = None
    globals()["groups"] = groups

    if not groups:
        document.getElementById("status").innerText = "Nenhum triangulo na tela."
    else:
        document.getElementById("status").innerText = "Triangulo excluido."
    draw()

document.getElementById("excluir").onclick = create_proxy(excluir_triangulo)

# --------- FUNCOES DE APOIO PARA CLIQUE/DRAG ----------
def compute_degrees_for_group(group):
    verts = {}
    for seg in group["segments"]:
        for key in ("p1", "p2"):
            p = seg[key]
            v = (round(p[0], 3), round(p[1], 3))
            verts[v] = verts.get(v, 0) + 1
    return verts

def handle_group_drag_click(group, mx, my):
    global dragging_segment, dragging_point, selected_group

    for seg in group["segments"]:
        p1, p2 = seg["p1"], seg["p2"]

        if distance((mx, my), p1) < 10:
            dragging_point = (group, seg, "p1")
            selected_group = group
            draw()
            return True
        if distance((mx, my), p2) < 10:
            dragging_point = (group, seg, "p2")
            selected_group = group
            draw()
            return True

        if distance(p1, p2) > 0:
            dist_pr = abs((p2[1] - p1[1])*mx - (p2[0] - p1[0])*my + p2[0]*p1[1] - p2[1]*p1[0]) / distance(p1, p2)
            if dist_pr < 8:
                dragging_segment = (group, seg)
                selected_group = group
                draw()
                return True
    return False

# ----------------- EVENTOS DE MOUSE --------------------
def on_mousedown(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse, selected_group

    mx = event.offsetX / zoom
    my = event.offsetY / zoom
    last_mouse = (mx, my)

    # 1) grupos travados
    for group in groups:
        if not group["locked"]:
            continue

        if not group["can_triangle"]:
            degrees = compute_degrees_for_group(group)
            for seg in group["segments"]:
                for name in ("p1", "p2"):
                    p = seg[name]
                    v = (round(p[0], 3), round(p[1], 3))
                    if degrees.get(v, 0) == 1 and distance((mx, my), p) < 10:
                        dragging_point = (group, seg, name)
                        selected_group = group
                        draw()
                        return

        for seg in group["segments"]:
            p1, p2 = seg["p1"], seg["p2"]
            if distance(p1, p2) > 0:
                dist_pr = abs((p2[1] - p1[1])*mx - (p2[0] - p1[0])*my + p2[0]*p1[1] - p2[1]*p1[0]) / distance(p1, p2)
                if dist_pr < 8:
                    dragging_triangle_group = group
                    selected_group = group
                    draw()
                    return

    # 2) grupo ativo
    if active_group is not None and not active_group["locked"]:
        if handle_group_drag_click(active_group, mx, my):
            return

    # 3) outros grupos nao travados
    for group in groups:
        if group is active_group or group["locked"]:
            continue
        if handle_group_drag_click(group, mx, my):
            return

    # 4) clique dentro de triangulo
    for group in groups:
        if group["polygon"] is not None:
            v0, v1, v2 = group["polygon"]
            if point_in_triangle((mx, my), v0, v1, v2):
                selected_group = group
                draw()
                return

def point_in_triangle(p, a, b, c):
    (px, py) = p
    (ax, ay) = a
    (bx, by) = b
    (cx, cy) = c

    denom = (by - cy)*(ax - cx) + (cx - bx)*(ay - cy)
    if denom == 0:
        return False
    u = ((by - cy)*(px - cx) + (cx - bx)*(py - cy)) / denom
    v = ((cy - ay)*(px - cx) + (ax - cx)*(py - cy)) / denom
    w = 1 - u - v
    return (0 <= u <= 1) and (0 <= v <= 1) and (0 <= w <= 1)

def on_mousemove(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse

    mx = event.offsetX / zoom
    my = event.offsetY / zoom
    if last_mouse is None:
        last_mouse = (mx, my)

    dx = mx - last_mouse[0]
    dy = my - last_mouse[1]
    last_mouse = (mx, my)

    # 1) arrastando grupo travado
    if dragging_triangle_group is not None:
        g = dragging_triangle_group

        for seg in g["segments"]:
            seg["p1"][0] += dx
            seg["p1"][1] += dy
            seg["p2"][0] += dx
            seg["p2"][1] += dy

        if g["polygon"] is not None:
            new_poly = []
            for (x, y) in g["polygon"]:
                new_poly.append((x + dx, y + dy))
            g["polygon"] = new_poly

        ra = g.get("right_angle")
        if ra is not None:
            for key in ("R", "A", "B"):
                (x, y) = ra[key]
                ra[key] = (x + dx, y + dy)

        draw()
        return

    # 2) arrastando segmento solto
    if dragging_segment is not None:
        group, seg = dragging_segment
        seg["p1"][0] += dx
        seg["p1"][1] += dy
        seg["p2"][0] += dx
        seg["p2"][1] += dy
        draw()
        return

    # 3) arrastando extremidade
    if dragging_point is not None:
        group, seg, name = dragging_point
        other = "p2" if name == "p1" else "p1"
        ox, oy = seg[other]
        vx = mx - ox
        vy = my - oy
        d = (vx*vx + vy*vy) ** 0.5
        if d == 0:
            return
        L = seg["len"]
        vx /= d
        vy /= d
        seg[name][0] = ox + vx * L
        seg[name][1] = oy + vy * L
        draw()
        return

def on_mouseup(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse

    dragging_segment = None
    dragging_point = None
    dragging_triangle_group = None
    last_mouse = None

    if active_group is not None and not active_group["locked"]]:
        snap_endpoints(active_group)
        check_triangle_formed(active_group)
        draw()

canvas.addEventListener("mousedown", create_proxy(on_mousedown))
canvas.addEventListener("mousemove", create_proxy(on_mousemove))
canvas.addEventListener("mouseup", create_proxy(on_mouseup))

# ----------------- ZOOM NO CANVAS --------------------
def on_wheel(event):
    global zoom
    delta = event.deltaY
    if delta < 0:
        zoom *= 1.1
    else:
        zoom /= 1.1
    if zoom < 0.4:
        zoom = 0.4
    if zoom > 3.0:
        zoom = 3.0
    draw()
    event.preventDefault()

canvas.addEventListener("wheel", create_proxy(on_wheel))

draw()
</script>

</body>
</html>


