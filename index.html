<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Triangulos Interativos - PyScript</title>

    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.3.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.3.1/core.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #fafafa;
        }

        .container {
            display: flex;
            gap: 20px;
        }

        #controls {
            width: 260px;
        }

        #canvas-container {
            border: 1px solid #000;
            background: white;
            position: relative;
        }

        canvas {
            border: 1px solid #aaa;
            display: block;
        }

        .input-row {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

<h2>Triangulos Interativos (PyScript)</h2>

<div class="container">

    <div id="controls">
        <div class="input-row">
            Lado A: <input type="text" id="ladoA" value="3">
        </div>

        <div class="input-row">
            Lado B: <input type="text" id="ladoB" value="4">
        </div>

        <div class="input-row">
            Lado C: <input type="text" id="ladoC" value="5">
        </div>

        <button id="gerar">Gerar Segmentos</button>
        <button id="excluir">Excluir Triangulo Selecionado</button>

        <div style="margin-top: 10px;">
            <strong>Zoom:</strong>
            <button id="zoomMais">+</button>
            <button id="zoomMenos">-</button>
        </div>

        <h4>Status:</h4>
        <div id="status">Aguardando dados.</div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="700" height="500"></canvas>
    </div>

</div>

<!-- ================== PYTHON (PyScript) ====================== -->
<script type="py">
from js import document
from pyodide.ffi import create_proxy
import math

canvas = document.getElementById("canvas")
ctx = canvas.getContext("2d")

# grupo: {
#   "segments":[...],
#   "locked":bool,
#   "polygon":[(x,y),...],
#   "can_triangle":bool,
#   "fillColor":str|None,
#   "right_angle": {"R":(x,y), "A":(x,y), "B":(x,y)} | None,
#   "sides":[a,b,c] (ordenados),
#   "angles":[ {vertex,p1,p2,value}, ... ],
#   "angle_ticks":[int,int,int],
#   "centroid":(cx,cy)
# }
groups = []
active_group = None
selected_group = None

dragging_segment = None      # (group, seg)
dragging_point = None        # (group, seg, "p1"/"p2")
dragging_triangle_group = None
last_mouse = None

zoom = 1.0
SNAP_DIST = 12

# ----------------- FUNCOES AUXILIARES --------------------
def set_inputs_enabled(enabled: bool):
    for _id in ("ladoA", "ladoB", "ladoC", "gerar"):
        document.getElementById(_id).disabled = not enabled

def distance(p1, p2):
    return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5

def draw_point(x, y, color):
    ctx.beginPath()
    ctx.fillStyle = color
    ctx.arc(x, y, 7, 0, 6.28)
    ctx.fill()

def classify_by_angles(a, b, c):
    """
    Classifica pelos angulos usando apenas os lados digitados.
    Devolve "acute", "right" ou "obtuse".
    a <= b <= c (ordenados).
    """
    a, b, c = sorted([a, b, c])
    if c == 0:
        return "acute"
    lhs = a*a + b*b
    rhs = c*c
    rel = abs(lhs - rhs) / max(rhs, 1.0)
    if rel < 1e-6:
        return "right"
    elif lhs > rhs:
        return "acute"
    else:
        return "obtuse"

def safe_acos(x):
    """arccos com clamp para [-1,1], resultado em graus."""
    if x < -1.0:
        x = -1.0
    if x > 1.0:
        x = 1.0
    return math.degrees(math.acos(x))

def draw_right_angle_mark(group):
    """Desenha o quadradinho no vertice reto, se houver."""
    ra = group.get("right_angle")
    if not ra:
        return
    (Rx, Ry) = ra["R"]
    (Ax, Ay) = ra["A"]
    (Bx, By) = ra["B"]

    v1x, v1y = Ax - Rx, Ay - Ry
    v2x, v2y = Bx - Rx, By - Ry
    d1 = math.hypot(v1x, v1y)
    d2 = math.hypot(v2x, v2y)
    if d1 == 0 or d2 == 0:
        return
    v1x /= d1; v1y /= d1
    v2x /= d2; v2y /= d2

    size = 18.0
    p1x = Rx + v1x * size
    p1y = Ry + v1y * size
    p3x = Rx + v2x * size
    p3y = Ry + v2y * size
    p2x = p1x + v2x * size
    p2y = p1y + v2y * size

    ctx.beginPath()
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.moveTo(Rx, Ry)
    ctx.lineTo(p1x, p1y)
    ctx.lineTo(p2x, p2y)
    ctx.lineTo(p3x, p3y)
    ctx.stroke()

def draw_side_marks(group):
    """Risquinhos em lados iguais (apos formar o triangulo)."""
    lens = [seg["len"] for seg in group["segments"]]
    eps = 1e-2
    e01 = abs(lens[0] - lens[1]) <= eps
    e02 = abs(lens[0] - lens[2]) <= eps
    e12 = abs(lens[1] - lens[2]) <= eps

    ticks = [0, 0, 0]
    if e01 and e02:
        ticks = [1, 1, 1]   # equilatero
    elif e01 and not e02 and not e12:
        ticks = [1, 1, 0]
    elif e02 and not e01 and not e12:
        ticks = [1, 0, 1]
    elif e12 and not e01 and not e02:
        ticks = [0, 1, 1]

    for i, seg in enumerate(group["segments"]):
        if ticks[i] <= 0:
            continue
        (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
        dx = x2 - x1
        dy = y2 - y1
        d = math.hypot(dx, dy)
        if d == 0:
            continue
        mx = (x1 + x2) / 2.0
        my = (y1 + y2) / 2.0
        nx = -dy / d
        ny = dx / d
        size = 10.0
        ex = nx * size / 2.0
        ey = ny * size / 2.0

        ctx.beginPath()
        ctx.strokeStyle = "black"
        ctx.lineWidth = 2
        ctx.moveTo(mx - ex, my - ey)
        ctx.lineTo(mx + ex, my + ey)
        ctx.stroke()

def draw_segment_label(seg):
    """Desenha o valor do lado (medida digitada) próximo ao segmento."""
    (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
    dx = x2 - x1
    dy = y2 - y1
    d = math.hypot(dx, dy)
    if d == 0:
        return

    mx = (x1 + x2) / 2.0
    my = (y1 + y2) / 2.0

    nx = -dy / d
    ny = dx / d

    offset = 16.0
    tx = mx + nx * offset
    ty = my + ny * offset

    val = seg.get("value", None)
    if val is None:
        return
    if abs(val - round(val)) < 1e-9:
        text = str(int(round(val)))
    else:
        text = f"{val:.2f}"

    ctx.save()
    ctx.font = "14px Arial"
    ctx.fillStyle = "black"
    ctx.fillText(text, tx, ty)
    ctx.restore()

def draw_angle_arcs(group):
    """Desenha arcos nos angulos (exceto o reto) e
       colore de verde fluorescente os angulos congruentes."""
    angles = group.get("angles")
    if not angles:
        return

    ticks = group.get("angle_ticks", [0, 0, 0])
    ctx.save()
    ctx.lineWidth = 2.0

    base_radius = 22.0
    congruent_color = "#00ff66"  # verde fluorescente

    for idx, ang in enumerate(angles):
        val = ang["value"]
        if abs(val - 90.0) < 1e-2:
            # angulo reto já tem quadradinho
            continue

        (Vx, Vy) = ang["vertex"]
        (Bx, By) = ang["p1"]
        (Cx, Cy) = ang["p2"]

        v1x, v1y = Bx - Vx, By - Vy
        v2x, v2y = Cx - Vx, Cy - Vy
        d1 = math.hypot(v1x, v1y)
        d2 = math.hypot(v2x, v2y)
        if d1 == 0 or d2 == 0:
            continue
        v1x /= d1; v1y /= d1
        v2x /= d2; v2y /= d2

        t1 = math.atan2(v1y, v1x)
        t2 = math.atan2(v2y, v2x)

        # arco menor
        delta = (t2 - t1) % (2 * math.pi)
        if delta > math.pi:
            t1, t2 = t2, t1

        radius = base_radius

        # cor: verde para angulos congruentes, preto para o resto
        if ticks[idx] > 0:
            ctx.strokeStyle = congruent_color
        else:
            ctx.strokeStyle = "black"

        ctx.beginPath()
        ctx.arc(Vx, Vy, radius, t1, t2, False)
        ctx.stroke()

    ctx.restore()

def draw_angle_labels(group):
    """Desenha os valores dos angulos, fora do triangulo."""
    angles = group.get("angles")
    centroid = group.get("centroid")
    if not angles or centroid is None:
        return

    (cx, cy) = centroid
    ctx.save()
    ctx.font = "14px Arial"
    ctx.fillStyle = "black"

    for ang in angles:
        (vx, vy) = ang["vertex"]
        val = ang["value"]

        dx = vx - cx
        dy = vy - cy
        d = math.hypot(dx, dy)
        if d == 0:
            continue

        # vetor para fora a partir do vertice (mesma distancia para todos)
        offset = 40.0     # afastado um pouco mais do vértice
        tx = vx + (dx / d) * offset
        ty = vy + (dy / d) * offset

        text = f"{val:.2f}\u00b0"
        ctx.fillText(text, tx, ty)

    ctx.restore()

def draw():
    ctx.setTransform(1, 0, 0, 1, 0, 0)
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.setTransform(zoom, 0, 0, zoom, 0, 0)

    for group in groups:
        # poligono (triangulo valido) se existir
        if group["polygon"] is not None:
            ctx.beginPath()
            if group.get("fillColor"):
                ctx.fillStyle = group["fillColor"]
            else:
                ctx.fillStyle = "rgba(0, 150, 255, 0.25)"
            v0, v1, v2 = group["polygon"]
            ctx.moveTo(*v0)
            ctx.lineTo(*v1)
            ctx.lineTo(*v2)
            ctx.closePath()
            ctx.fill()

            # marcações extras
            draw_side_marks(group)
            draw_right_angle_mark(group)
            draw_angle_arcs(group)
            draw_angle_labels(group)

        # segmentos
        for seg in group["segments"]:
            (x1, y1), (x2, y2) = seg["p1"], seg["p2"]
            ctx.beginPath()
            ctx.lineWidth = 4
            ctx.strokeStyle = seg["color"]
            ctx.moveTo(x1, y1)
            ctx.lineTo(x2, y2)
            ctx.stroke()
            draw_point(x1, y1, seg["color"])
            draw_point(x2, y2, seg["color"])

            # medida do lado
            draw_segment_label(seg)

def snap_endpoints(group):
    """Cola pontas proximas dentro de um mesmo grupo."""
    pts = []
    for seg in group["segments"]:
        pts.append(seg["p1"])
        pts.append(seg["p2"])

    n = len(pts)
    for i in range(n):
        for j in range(i + 1, n):
            p1 = pts[i]
            p2 = pts[j]
            if distance(p1, p2) <= SNAP_DIST:
                mx = (p1[0] + p2[0]) / 2
                my = (p1[1] + p2[1]) / 2
                p1[0], p1[1] = mx, my
                p2[0], p2[1] = mx, my

def compute_angles_and_marks(group, v0, v1, v2, tipo_ang):
    """
    Calcula angulos usando EXATAMENTE os lados digitados (valores nos segmentos),
    ajusta para:
      - retangulo: 90 exato;
      - isosceles: dois angulos exatamente iguais;
      - equilatero: 60,60,60;
    define centroid, estrutura de angulos e grupos de congruencia.
    """
    verts = [v0, v1, v2]

    # ---- Recuperar os comprimentos dos lados a partir dos segmentos (valores digitados)
    def same_point(a, b, tol=1e-3):
        return abs(a[0]-b[0]) <= tol and abs(a[1]-b[1]) <= tol

    s01 = s12 = s20 = None

    for seg in group["segments"]:
        p1 = (seg["p1"][0], seg["p1"][1])
        p2 = (seg["p2"][0], seg["p2"][1])
        val = seg.get("value", None)
        if val is None:
            continue

        if (same_point(p1, v0) and same_point(p2, v1)) or (same_point(p1, v1) and same_point(p2, v0)):
            s01 = val
        elif (same_point(p1, v1) and same_point(p2, v2)) or (same_point(p1, v2) and same_point(p2, v1)):
            s12 = val
        elif (same_point(p1, v2) and same_point(p2, v0)) or (same_point(p1, v0) and same_point(p2, v2)):
            s20 = val

    # fallback: comprimentos geométricos
    if s01 is None:
        s01 = distance(v0, v1)
    if s12 is None:
        s12 = distance(v1, v2)
    if s20 is None:
        s20 = distance(v2, v0)

    # ---- Angulos brutos pela Lei dos Cossenos
    # lado oposto ao vertice:
    #  - v0 oposto a s12
    #  - v1 oposto a s20
    #  - v2 oposto a s01
    A0 = safe_acos((s01*s01 + s20*s20 - s12*s12) / (2.0 * s01 * s20))
    A1 = safe_acos((s01*s01 + s12*s12 - s20*s20) / (2.0 * s01 * s12))
    A2 = safe_acos((s12*s12 + s20*s20 - s01*s01) / (2.0 * s12 * s20))
    angles = [A0, A1, A2]

    # ---- Verificar tipos pelos lados
    eps_side = 1e-6
    eq01 = abs(s01 - s12) < eps_side
    eq12 = abs(s12 - s20) < eps_side
    eq20 = abs(s20 - s01) < eps_side

    # Equilatero: três lados praticamente iguais
    if eq01 and eq12:
        angles = [60.0, 60.0, 60.0]
    else:
        # Detectar par de lados iguais (isosceles, possivelmente retangulo isosceles)
        iso_pair = None
        # s01 (v0-v1) oposto ao vertice v2
        # s12 (v1-v2) oposto ao vertice v0
        # s20 (v2-v0) oposto ao vertice v1
        if eq01:
            iso_pair = (2, 0)  # angulos em v2 e v0
        elif eq12:
            iso_pair = (0, 1)  # angulos em v0 e v1
        elif eq20:
            iso_pair = (1, 2)  # angulos em v1 e v2

        # Ajuste para triângulo retângulo: um ângulo = 90 exato
        if tipo_ang == "right":
            idx_max = max(range(3), key=lambda i: angles[i])
            right_exact = 90.0
            others = [i for i in range(3) if i != idx_max]
            sum_others = angles[others[0]] + angles[others[1]]
            if sum_others > 0:
                scale = (180.0 - right_exact) / sum_others
                for i in others:
                    angles[i] *= scale
            angles[idx_max] = right_exact

        # Ajuste isosceles (sem ser equilátero)
        if iso_pair is not None and not (eq01 and eq12):
            i, j = iso_pair
            v = (angles[i] + angles[j]) / 2.0
            angles[i] = v
            angles[j] = v
            k = 3 - i - j
            angles[k] = 180.0 - 2.0 * v

    # Ajuste final para garantir soma = 180 (residuo numerico)
    total = sum(angles)
    diff = 180.0 - total
    angles[0] += diff

    # ---- Definir grupos de congruencia pelos angulos finais
    eps_ang = 1e-2
    equal01 = abs(angles[0] - angles[1]) < eps_ang
    equal12 = abs(angles[1] - angles[2]) < eps_ang
    equal02 = abs(angles[0] - angles[2]) < eps_ang
    angle_ticks = [0, 0, 0]
    if equal01 and equal12:
        angle_ticks = [1, 1, 1]
    elif equal01:
        angle_ticks = [1, 1, 0]
    elif equal12:
        angle_ticks = [0, 1, 1]
    elif equal02:
        angle_ticks = [1, 0, 1]

    # ---- Centroid
    cx = (v0[0] + v1[0] + v2[0]) / 3.0
    cy = (v0[1] + v1[1] + v2[1]) / 3.0

    # ---- Estrutura dos angulos (associar vértices para desenho de arcos)
    angles_struct = []
    for i in range(3):
        V = verts[i]
        P1 = verts[(i - 1) % 3]
        P2 = verts[(i + 1) % 3]
        angles_struct.append({
            "vertex": V,
            "p1": P1,
            "p2": P2,
            "value": angles[i],
        })

    group["angles"] = angles_struct
    group["angle_ticks"] = angle_ticks
    group["centroid"] = (cx, cy)

def check_triangle_formed(group):
    """Detecta conexao dos 3 segmentos."""
    global active_group, selected_group

    group["right_angle"] = None
    group["fillColor"] = None
    group["angles"] = None
    group["angle_ticks"] = [0, 0, 0]
    group["centroid"] = None

    verts = {}
    for seg in group["segments"]:
        for key in ("p1", "p2"):
            p = seg[key]
            v = (round(p[0], 3), round(p[1], 3))
            verts[v] = verts.get(v, 0) + 1

    num_verts = len(verts)
    degrees = list(verts.values())

    # ----------- CASO 1: TRIANGULO FECHADO ----------
    if num_verts == 3 and all(d == 2 for d in degrees):
        group["locked"] = True
        active_group = None
        selected_group = group
        set_inputs_enabled(True)

        xs = [v[0] for v in verts.keys()]
        ys = [v[1] for v in verts.keys()]
        cx_tmp = sum(xs) / 3
        cy_tmp = sum(ys) / 3
        verts_sorted = sorted(verts.keys(), key=lambda v: math.atan2(v[1]-cy_tmp, v[0]-cx_tmp))
        v0, v1, v2 = verts_sorted

        # comprimentos geometricos (para achar lado maior para o ângulo reto)
        L01 = distance(v0, v1)
        L12 = distance(v1, v2)
        L20 = distance(v2, v0)

        if (L01 + L12 > L20) and (L01 + L20 > L12) and (L12 + L20 > L01):
            # classificação pelos lados digitados
            a, b, c = group["sides"]
            tipo_ang = classify_by_angles(a, b, c)

            if tipo_ang == "acute":
                group["fillColor"] = "rgba(255, 0, 0, 0.5)"   # vermelho
            elif tipo_ang == "right":
                group["fillColor"] = "rgba(0, 200, 0, 0.5)"   # verde
            else:
                group["fillColor"] = "rgba(0, 0, 255, 0.5)"   # azul

            group["polygon"] = [v0, v1, v2]

            # segmentos pretos depois de formar
            for seg in group["segments"]:
                seg["color"] = "black"

            # angulo reto -> vertice oposto ao maior lado geometrico
            if tipo_ang == "right":
                lens = [L01, L12, L20]
                max_idx = max(range(3), key=lambda i: lens[i])
                if max_idx == 0:
                    R = v2; A = v0; B = v1
                elif max_idx == 1:
                    R = v0; A = v1; B = v2
                else:
                    R = v1; A = v2; B = v0
                group["right_angle"] = {"R": R, "A": A, "B": B}

            # calcula angulos, centroid e grupos de congruencia
            compute_angles_and_marks(group, v0, v1, v2, tipo_ang)

            nome = "acutangulo" if tipo_ang=="acute" else "retangulo" if tipo_ang=="right" else "obtusangulo"
            document.getElementById("status").innerText = (
                f"Triangulo valido formado! ({nome}) Voce pode inserir novos lados."
            )
        else:
            group["polygon"] = None
            document.getElementById("status").innerText = (
                "Segmentos conectados em loop. Observe se eles formam um triangulo valido."
            )
        return

    # ----------- CASO 2: CADEIA ABERTA CONECTADA (1-1-2-2) -----------  
    if not group["can_triangle"]:
        if num_verts == 4 and sorted(degrees) == [1, 1, 2, 2]:
            group["locked"] = True
            active_group = None
            selected_group = group
            set_inputs_enabled(True)
            group["polygon"] = None
            document.getElementById("status").innerText = (
                "Segmentos conectados em cadeia. Voce pode inserir novos lados e continuar investigando."
            )
            return

def gerar_segmentos(event=None):
    global groups, active_group, selected_group

    if active_group is not None:
        document.getElementById("status").innerText = (
            "Conecte primeiro o conjunto atual antes de gerar outro."
        )
        return

    try:
        a = float(document.getElementById("ladoA").value)
        b = float(document.getElementById("ladoB").value)
        c = float(document.getElementById("ladoC").value)
    except Exception:
        document.getElementById("status").innerText = "Valores invalidos."
        return

    esc = 40

    segs = [
        {"p1": [100, 100], "p2": [100 + a*esc, 100], "len": a*esc, "color": "red",  "value": a},
        {"p1": [100, 200], "p2": [100 + b*esc, 200], "len": b*esc, "color": "green","value": b},
        {"p1": [100, 300], "p2": [100 + c*esc, 300], "len": c*esc, "color": "blue", "value": c},
    ]

    can_triangle = (a + b > c) and (a + c > b) and (b + c > a)

    group = {
        "segments": segs,
        "locked": False,
        "polygon": None,
        "can_triangle": can_triangle,
        "fillColor": None,
        "right_angle": None,
        "sides": sorted([a, b, c]),
        "angles": None,
        "angle_ticks": [0, 0, 0],
        "centroid": None,
    }

    groups.append(group)
    active_group = group
    selected_group = group

    set_inputs_enabled(False)
    # Mensagem única, incentivando a exploração em TODOS os casos
    document.getElementById("status").innerText = (
        "Conecte os segmentos e tente formar um triangulo."
    )
    draw()

document.getElementById("gerar").onclick = create_proxy(gerar_segmentos)

def excluir_triangulo(event=None):
    global groups, active_group, selected_group

    if selected_group is None:
        document.getElementById("status").innerText = "Nenhum triangulo selecionado."
        return

    if selected_group is active_group:
        active_group = None
        set_inputs_enabled(True)

    groups = [g for g in groups if g is not selected_group]
    selected_group = None
    globals()["groups"] = groups

    if not groups:
        document.getElementById("status").innerText = "Nenhum triangulo na tela."
    else:
        document.getElementById("status").innerText = "Triangulo excluido."
    draw()

document.getElementById("excluir").onclick = create_proxy(excluir_triangulo)

# --------- FUNCOES DE APOIO PARA CLIQUE/DRAG ----------
def compute_degrees_for_group(group):
    verts = {}
    for seg in group["segments"]:
        for key in ("p1", "p2"):
            p = seg[key]
            v = (round(p[0], 3), round(p[1], 3))
            verts[v] = verts.get(v, 0) + 1
    return verts

def handle_group_drag_click(group, mx, my):
    global dragging_segment, dragging_point, selected_group

    for seg in group["segments"]:
        p1, p2 = seg["p1"], seg["p2"]

        if distance((mx, my), p1) < 10:
            dragging_point = (group, seg, "p1")
            selected_group = group
            draw()
            return True
        if distance((mx, my), p2) < 10:
            dragging_point = (group, seg, "p2")
            selected_group = group
            draw()
            return True

        if distance(p1, p2) > 0:
            dist_pr = abs((p2[1] - p1[1])*mx - (p2[0] - p1[0])*my + p2[0]*p1[1] - p2[1]*p1[0]) / distance(p1, p2)
            if dist_pr < 8:
                dragging_segment = (group, seg)
                selected_group = group
                draw()
                return True
    return False

# ----------------- EVENTOS DE MOUSE --------------------
def on_mousedown(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse, selected_group

    mx = event.offsetX / zoom
    my = event.offsetY / zoom
    last_mouse = (mx, my)

    # 1) grupos travados
    for group in groups:
        if not group["locked"]:
            continue

        if not group["can_triangle"]:
            degrees = compute_degrees_for_group(group)
            for seg in group["segments"]:
                for name in ("p1", "p2"):
                    p = seg[name]
                    v = (round(p[0], 3), round(p[1], 3))
                    if degrees.get(v, 0) == 1 and distance((mx, my), p) < 10:
                        dragging_point = (group, seg, name)
                        selected_group = group
                        draw()
                        return

        for seg in group["segments"]:
            p1, p2 = seg["p1"], seg["p2"]
            if distance(p1, p2) > 0:
                dist_pr = abs((p2[1] - p1[1])*mx - (p2[0] - p1[0])*my + p2[0]*p1[1] - p2[1]*p1[0]) / distance(p1, p2)
                if dist_pr < 8:
                    dragging_triangle_group = group
                    selected_group = group
                    draw()
                    return

    # 2) grupo ativo
    if active_group is not None and not active_group["locked"]:
        if handle_group_drag_click(active_group, mx, my):
            return

    # 3) outros grupos nao travados
    for group in groups:
        if group is active_group or group["locked"]:
            continue
        if handle_group_drag_click(group, mx, my):
            return

    # 4) clique dentro de triangulo
    for group in groups:
        if group["polygon"] is not None:
            v0, v1, v2 = group["polygon"]
            if point_in_triangle((mx, my), v0, v1, v2):
                selected_group = group
                draw()
                return

def point_in_triangle(p, a, b, c):
    (px, py) = p
    (ax, ay) = a
    (bx, by) = b
    (cx, cy) = c

    denom = (by - cy)*(ax - cx) + (cx - bx)*(ay - cy)
    if denom == 0:
        return False
    u = ((by - cy)*(px - cx) + (cx - bx)*(py - cy)) / denom
    v = ((cy - ay)*(px - cx) + (ax - cx)*(py - cy)) / denom
    w = 1 - u - v
    return (0 <= u <= 1) and (0 <= v <= 1) and (0 <= w <= 1)

def on_mousemove(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse

    mx = event.offsetX / zoom
    my = event.offsetY / zoom
    if last_mouse is None:
        last_mouse = (mx, my)

    dx = mx - last_mouse[0]
    dy = my - last_mouse[1]
    last_mouse = (mx, my)

    # 1) arrastando grupo travado
    if dragging_triangle_group is not None:
        g = dragging_triangle_group

        for seg in g["segments"]:
            seg["p1"][0] += dx
            seg["p1"][1] += dy
            seg["p2"][0] += dx
            seg["p2"][1] += dy

        if g["polygon"] is not None:
            new_poly = []
            for (x, y) in g["polygon"]:
                new_poly.append((x + dx, y + dy))
            g["polygon"] = new_poly

        ra = g.get("right_angle")
        if ra is not None:
            for key in ("R", "A", "B"):
                (x, y) = ra[key]
                ra[key] = (x + dx, y + dy)

        # mover centroid e vertices dos angulos
        if g.get("centroid") is not None:
            (cx, cy) = g["centroid"]
            g["centroid"] = (cx + dx, cy + dy)

        if g.get("angles") is not None:
            for ang in g["angles"]:
                (vx, vy) = ang["vertex"]
                (p1x, p1y) = ang["p1"]
                (p2x, p2y) = ang["p2"]
                ang["vertex"] = (vx + dx, vy + dy)
                ang["p1"] = (p1x + dx, p1y + dy)
                ang["p2"] = (p2x + dx, p2y + dy)

        draw()
        return

    # 2) arrastando segmento solto
    if dragging_segment is not None:
        group, seg = dragging_segment
        seg["p1"][0] += dx
        seg["p1"][1] += dy
        seg["p2"][0] += dx
        seg["p2"][1] += dy
        draw()
        return

    # 3) arrastando extremidade
    if dragging_point is not None:
        group, seg, name = dragging_point
        other = "p2" if name == "p1" else "p1"
        ox, oy = seg[other]
        vx = mx - ox
        vy = my - oy
        d = (vx*vx + vy*vy) ** 0.5
        if d == 0:
            return
        L = seg["len"]
        vx /= d
        vy /= d
        seg[name][0] = ox + vx * L
        seg[name][1] = oy + vy * L
        draw()
        return

def on_mouseup(event):
    global dragging_segment, dragging_point, dragging_triangle_group, last_mouse

    dragging_segment = None
    dragging_point = None
    dragging_triangle_group = None
    last_mouse = None

    if active_group is not None and not active_group["locked"]:
        snap_endpoints(active_group)
        check_triangle_formed(active_group)
        draw()

canvas.addEventListener("mousedown", create_proxy(on_mousedown))
canvas.addEventListener("mousemove", create_proxy(on_mousemove))
canvas.addEventListener("mouseup", create_proxy(on_mouseup))

# ----------------- ZOOM NO CANVAS --------------------
def apply_zoom(factor):
    global zoom
    zoom *= factor
    if zoom < 0.4:
        zoom = 0.4
    if zoom > 3.0:
        zoom = 3.0
    draw()

def zoom_in(event=None):
    apply_zoom(1.1)

def zoom_out(event=None):
    apply_zoom(1/1.1)

def on_wheel(event):
    delta = event.deltaY
    if delta < 0:
        apply_zoom(1.1)
    else:
        apply_zoom(1/1.1)
    event.preventDefault()

canvas.addEventListener("wheel", create_proxy(on_wheel))

document.getElementById("zoomMais").onclick = create_proxy(zoom_in)
document.getElementById("zoomMenos").onclick = create_proxy(zoom_out)

draw()
</script>

</body>
</html>
